1.LB负载均衡（Load Balance）是什么？
简单的说就是将用户的请求，平摊的分配到多个服务上，从而达到系统的HA高可用。常见的负载均衡
有软件Nginx,LVS,硬件F5等

2.Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡区别？
Nginx是服务器负载均衡，客户端所以请求都会交给Nginx,然后有Nginx实现转发请求。即负载均衡是由服务器实现的。
Ribbon本地负载均衡，在调用微服务接口时，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从
而在本地实现RPC远程服务调用技术。

3.集中式LB
即在服务的消费方和服务提供方之间使用独立的LB设施（可以是硬件，如F5，也可以是软件，如Nginx）,由
该设施负责把访问请求通过某种策略转发

4.进程内LB
将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个
合适的服务器。Ribbon就属于进程内LB,它只是一个类库，集成于消费方进程，消费方通过它来获取到服务
提供方的地址。Ribbon 一句话就是 负载均衡+RestTemplate调用

5.Ribbon在工作时分2步
第一步，先选择EurekaServer或是其他集成Ribbon的服务注册中心，它优先选择在同一区域内
负载较少的server.
第二步，再根据用户指定的策略，在从server获取到的服务注册列表中选择一个地址。
其中Ribbon提供了多种策略，比如 轮询、随机、和根据相应时间加权

6.Hystrix(豪猪哥) 非常重要 服务降级
出道即是巅峰，虽然现在spring官方停更，但是后面做服务降级的框架都是借鉴于它
服务雪崩：
多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又
调用其他的微服，这就是所谓的 "扇出"。如果扇出的链路上某个微服务的调用响应时间
过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，
所谓的 "雪崩效应"。
Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用
失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免
级联故障，以提供分布式系统的弹性。
"断路器" 本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似于熔断）
保险丝，向调用方返回一个符合预期的，可处理的备选响应（FallBack），而不是长时间的等待或者
抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要的占用，从而避免
了故障在分布式系统中的蔓延、乃至雪崩
hystrix的服务降级，是通过fallback返回给调用者一个友好的提示信息。而服务熔断，是当检测到
该节点微服务调用响应正常后，恢复链路调用，这2者是2个不同的概念。
7.网关 zuul (弃用),zuul2(还没有发布出来)（netflix公司出的） 
现在使用新一代网关 gateway(spring公司出的)
springCloud Gateway 是spring Cloud的一个全新项目，基于spring5.0+springboot2.0和
Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一API路由管理方式。
springCloud Gateway作为 spring Cloud生态系统中的网关，目标是替代zuul，在 
springCloud2.0 以上版本中，没有对新版本的zuul 2.0以上最新高性能版本进行集成，仍然还是
使用的是 zuul 1.x 非Reactor模式的老版本，而为了提升网关性能，springCloud Gateway是
基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通用框架Netty.
springCloud Gateway 的目标提供统一的路由方式且基于 Filter链的方式提供了网关基本的功能
，例如：安全，监控/指标，和限流
7.1 zuul 1.x 是一个基于阻塞 I/O 的API Gateway
7.2 zuul 1.x 基于servlet 2.5 使用阻塞架构，它不支持任何长连接（如websocket）,zuul 的设计
模式和nginx较像，每次I/O都是从工作线程中选一个执行，请求线程被阻塞到工作线程完成，但是差别
是nginx是使用C++实现的，zuul是使用java实现的，而JVM本身会有第一次加载较慢的情况，使得
zuul的性能相对较差
7.3 zuul 2.x理念更先进，想基于Netty非阻塞和支持长连接，但springCloud目前还没有整合
在性能方面，根据官方提供的基准测试，springCloud Gateway的PRS(每秒请求数)是zuul的1.6倍
7.4 springCloud Gateway建立在spring Framework 5 、Project Reactor和springboot2.0
之上，使用非阻塞AP。
7.5 springCloud Gateway 还支持 websocket,并且与spring紧密集成拥有更好的开发体验
8.zookeeper 分布式协调服务框架 服务治理
分布式协调：解决分布式环境中多个进程之间的同步控制，让它们有序去访问某种临界资源，防止造成
脏数据。比如说某个订单服务，放在docker中起了3台服务器，就是3个进程，3个JVM.高并发下，
每台服务器有5个线程操作去操作商品服务数据，商品服务 也被消耗了5个，就造成了脏数据。进程之间
没法用同步锁，只能用分布式锁，zookeeper就是一个实现分布式锁的框架，让3个进程有序进行去
操作商品服务，1台操作完了返回了，第二台才能操作。。。就不会造成脏数据。

9.分布式锁的实现有哪些？
9.1 Memcached 利用add命令，此命令是原子性操作，只有在key不存在的情况下，才能add成功，
也就意味这线程得到了锁。
9.2 redis 和 Memcached类似，利用redis的 setnx 命令，此命令同样是原子性的（lua脚本）
，只有在key不存在的情况下，才能set 成功。
9.3 利用zookeeper的顺序临时节点，来实现分布式锁和等待队列，zookeeper设计的初衷，就是
为了实现分布式锁服务的。
9.4 Chubby Google公司实现的粗粒度分布式锁服务，底层利用了Paxos一致性算法。
redis分布式锁具体实现原理：比如现在有2个JVM要去修改某个商品库存。JVM1先去redis里使用
setnx (商品I（唯一）,value),如果返回0，
说明该商品没有被锁住，可以进行操作，如果返回1则说明该商品已被加锁，不能进行操作了。有加锁
肯定有解锁，当JVM1操作完该商品，利用redis.del(商品ID）释放锁，这个时候JVM2再使用setnx
(商品ID），发现返回0，JVM2这时候就可以对该商品进行操作了
如果JVM1 加完锁（setnx），还没有来得及释放锁(del),JVM1突然宕机了，这时候就造成了死锁。
所以我们需要设置一个锁(key)的过期时间 exprie 

**项目github地址：https://github.com/467812367/cloud2020.git

##
